print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
rmse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
#Alternativ Funktion rmse_model benutzen
rmse_model(test_sample, linear_mod_pred, "SalePrice")
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:1100],]
test_sample <- traindata_3[shuffle[1101:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
rmse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
#Alternativ Funktion rmse_model benutzen
rmse_model(test_sample, linear_mod_pred, "SalePrice")
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:1100],]
test_sample <- traindata_3[shuffle[1101:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
rmse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
#Alternativ Funktion rmse_model benutzen
rmse_model(test_sample, linear_mod_pred, "SalePrice")
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:1100],]
test_sample <- traindata_3[shuffle[1101:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
rmse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
#Alternativ Funktion rmse_model benutzen
rmse_model(test_sample, linear_mod_pred, "SalePrice")
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:1100],]
test_sample <- traindata_3[shuffle[1101:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
rmse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
#Alternativ Funktion rmse_model benutzen
rmse_model(test_sample, linear_mod_pred, "SalePrice")
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:1100],]
test_sample <- traindata_3[shuffle[1101:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
rmse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
#Alternativ Funktion rmse_model benutzen
rmse_model(test_sample, linear_mod_pred, "SalePrice")
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:1100],]
test_sample <- traindata_3[shuffle[1101:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
rmse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
#Alternativ Funktion rmse_model benutzen
rmse_model(test_sample, linear_mod_pred, "SalePrice")
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:1100],]
test_sample <- traindata_3[shuffle[1101:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
rmse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
#Alternativ Funktion rmse_model benutzen
rmse_model(test_sample, linear_mod_pred, "SalePrice")
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:1100],]
test_sample <- traindata_3[shuffle[1101:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
rmse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
#Alternativ Funktion rmse_model benutzen
rmse_model(test_sample, linear_mod_pred, "SalePrice")
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:1100],]
test_sample <- traindata_3[shuffle[1101:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
rmse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
#Alternativ Funktion rmse_model benutzen
rmse_model(test_sample, linear_mod_pred, "SalePrice")
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:1100],]
test_sample <- traindata_3[shuffle[1101:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
rmse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
#Alternativ Funktion rmse_model benutzen
rmse_model(test_sample, linear_mod_pred, "SalePrice")
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:1100],]
test_sample <- traindata_3[shuffle[1101:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
rmse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
#Alternativ Funktion rmse_model benutzen
rmse_model(test_sample, linear_mod_pred, "SalePrice")
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:1100],]
test_sample <- traindata_3[shuffle[1101:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
rmse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
#Alternativ Funktion rmse_model benutzen
rmse_model(test_sample, linear_mod_pred, "SalePrice")
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:1100],]
test_sample <- traindata_3[shuffle[1101:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
rmse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
#Alternativ Funktion rmse_model benutzen
rmse_model(test_sample, linear_mod_pred, "SalePrice")
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:1100],]
test_sample <- traindata_3[shuffle[1101:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
rmse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
#Alternativ Funktion rmse_model benutzen
rmse_model(test_sample, linear_mod_pred, "SalePrice")
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:1100],]
test_sample <- traindata_3[shuffle[1101:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
rmse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
#Alternativ Funktion rmse_model benutzen
rmse_model(test_sample, linear_mod_pred, "SalePrice")
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:1100],]
test_sample <- traindata_3[shuffle[1101:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
rmse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
#Alternativ Funktion rmse_model benutzen
rmse_model(test_sample, linear_mod_pred, "SalePrice")
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:1100],]
test_sample <- traindata_3[shuffle[1101:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
rmse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
#Alternativ Funktion rmse_model benutzen
rmse_model(test_sample, linear_mod_pred, "SalePrice")
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:1100],]
test_sample <- traindata_3[shuffle[1101:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
rmse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
#Alternativ Funktion rmse_model benutzen
rmse_model(test_sample, linear_mod_pred, "SalePrice")
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:1100],]
test_sample <- traindata_3[shuffle[1101:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
rmse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
#Alternativ Funktion rmse_model benutzen
rmse_model(test_sample, linear_mod_pred, "SalePrice")
library(dplyr)
library(Metrics)
library(stringr)
library(readr)
traindata = read.csv("01_Data/train.csv", stringsAsFactors = FALSE)
traindata$Id <- NULL
traindata_2 <- traindata[,c(13,14,17,18,19,27,28,30,31,38,39,40,41,42,46,49:54,61,62,71,78,79,80)]
linear_mod <- lm(formula = SalePrice ~., data=traindata_2)
linear_mod_test <- lm(formula =SalePrice~SaleCondition, data=traindata)
print(linear_mod)
summary(linear_mod)
traindata_3 <- traindata_2[,c(3,4,5,6,8,10,15,19,20,22,26,27)]
linear_mod_new <- lm(formula = SalePrice~., data=traindata_3)
summary(linear_mod_new)
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:730],]
test_sample <- traindata_3[shuffle[731:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
mse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:730],]
test_sample <- traindata_3[shuffle[731:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
mse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:730],]
test_sample <- traindata_3[shuffle[731:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
mse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:730],]
test_sample <- traindata_3[shuffle[731:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
mse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:730],]
test_sample <- traindata_3[shuffle[731:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
mse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:730],]
test_sample <- traindata_3[shuffle[731:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
mse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :D
partial <- filter(test_sample, SaleCondition == "Partial")
mse(partial$SalePrice, partial$SalePrice_Prediction)
partial_all <- filter(traindata, SaleCondition == "Partial")
npartial_all <- filter(traindata, SaleCondition != "Partial")
mean(partial_all$SalePrice)
mean(npartial_all$SalePrice) #-> Häuser mit der SaleCondition Partial sind im Schnitt 100,000 Dollar teurer
View(test_sample)
train_sample <- traindata_3[shuffle[1:730],]
test_sample <- traindata_3[shuffle[731:1460],]
1460-731
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
mse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :
test_sample <- na.omit(test_sample)
mse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :
train_sample$SalePrice_Prediciton <- predict(linear_mod_pred, train_sample)
View(train_sample)
train_sample <- na.omit(train_sample)
mse(train_sample$SalePrice, train_sample$SalePrice_Prediction)
train_sample <- na.omit(train_sample)
mse(train_sample$SalePrice, train_sample$SalePrice_Prediction)
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:730],]
test_sample <- traindata_3[shuffle[731:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
mse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :
train_sample$SalePrice_Prediction <- predict(linear_mod_pred, train_sample)
train_sample <- na.omit(train_sample)
mse(train_sample$SalePrice, train_sample$SalePrice_Prediction)
train_sample$Exp <- (train_sample$SalePrice_Prediction - train_sample$SalePrice)^2
train_sample$Exp <- (1/1000)*(train_sample$SalePrice_Prediction - train_sample$SalePrice)^2
train_sample$Exp <- (1/1000000)*(train_sample$SalePrice_Prediction - train_sample$SalePrice)^2
hist(train_sample)
?arrange
?head
?arrange
train_sample <- arrange(train_sample, desc(Exp))
close <- tail(train_sample, n = 25)
spread <- head(train_sample, n = 25)
View(close)
hist(close$SaleCondition)
mean(close$OverallQual)
mean(spread$OverallQual)
?median
median(close$OverallQual)
median(spread$OverallQual)
mean(close$OverallCond)
mean(spread$OverallCond)
mean(close$YearBuilt)
mean(spread$YearBuilt)
median(close$YearBuilt)
median(spread$YearBuilt)
View(spread)
table(spread$SaleCondition)
table(close$SaleCondition)
table(spread$SaleCondition)
print(linear_mod)
summary(linear_mod)
traindata_3 <- traindata_2[,c(3,4,5,6,8,10,15,19,20,22,26,27)]
colnames(traindata_3)
traindata_3 <- traindata_2[,c(3,4,5,6,8,10,15,19,20,22,27)]
linear_mod_new <- lm(formula = SalePrice~., data=traindata_3)
summary(linear_mod_new)
#Erstelle train und test samples, um linear_mod_new zu testen
shuffle <- sample(1460)   #das hier ist mehr oder weniger Problematisch, da das samplen Einfluss auf die Signifkanz der Variablen hat
train_sample <- traindata_3[shuffle[1:730],]
test_sample <- traindata_3[shuffle[731:1460],]
linear_mod_pred <- lm(formula = SalePrice~., data=train_sample)
print(linear_mod_pred)
summary(linear_mod_pred)
test_sample$SalePrice_Prediction <- predict(linear_mod_pred, test_sample)
#Wenn kein Basement vorhanden ist, wird NA predicted, diese werden für die Berechnung des mse erstmal rausgenommen
#Man kann/sollte alternativ die NA's in BsmtQual ersetzen
test_sample <- na.omit(test_sample)
mse(test_sample$SalePrice, test_sample$SalePrice_Prediction) #Die Fehler sind immer noch riesig, aber die geringsten die ich bis jetzt hatte :
train_sample$SalePrice_Prediction <- predict(linear_mod_pred, train_sample)
train_sample <- na.omit(train_sample)
mse(train_sample$SalePrice, train_sample$SalePrice_Prediction)
train_sample$Exp <- (1/1000000)*(train_sample$SalePrice_Prediction - train_sample$SalePrice)^2
train_sample <- arrange(train_sample, desc(Exp))
close <- tail(train_sample, n = 25)
spread <- head(train_sample, n = 25)
mean(close$OverallQual)
mean(spread$OverallQual) # ein Unterschied von ca. 1.5 bei der OverallQual der Häuser, median bringt hier nix
mean(close$OverallCond)
mean(spread$OverallCond) # hier kein großer Unterschied
mean(close$YearBuilt)
mean(spread$YearBuilt)
median(close$YearBuilt)
median(spread$YearBuilt) #
library(dplyr)
library(Metrics)
library(stringr)
library(readr)
data = read.csv("01_Data/train.csv", stringsAsFactors = FALSE)
data$Id <- NULL
str(data)
?sapply
sapply(data, is.factor)
sapply(data, is.character)
str(data)
data_chr <- data[,sapply(data, is.character)]
data_int <- data[,sapply(data, is.integer)]
cor(data_int)
?colSums
colSums(is.na(data_chr))
colSums(is.na(data_int))
View(data_int)
colnames(data_int)
colSums(is.na(data_chr))
colSums(is.na(data_int))
data_int[is.na(data_int$LotFrontage),]$LotFrontage <- 0
colSums(is.na(data_int))
data_chr <- data[,sapply(data, is.character)]
data_int <- data[,sapply(data, is.integer)]
colSums(is.na(data_chr))
colSums(is.na(data_int))
#Ersetze LotFrontage NA durch 0
data[is.na(data$LotFrontage),]$LotFrontage <- 0
View(data)
View(data_chr)
data[is.na(data$Alley),]$Alley <- "NoAlley"
View(data)
data[is.na(data$MiscFeature),]$MiscFeature <- "NoMisc"
colSums(is.na(data_chr))
data[is.na(data$Fence),]$Fence <- "NoFence"
data[is.na(data$PoolQC),]$PoolQC <- "NoPool"
data = read.csv("01_Data/train.csv", stringsAsFactors = TRUE)
data$Id <- NULL
#Unterteile Daten in Numerische und Kategorielle Variablen
data_chr <- data[,sapply(data, is.character)]
data_int <- data[,sapply(data, is.integer)]
colSums(is.na(data_chr))
colSums(is.na(data_int))
#Ersetze LotFrontage NA durch 0
data[is.na(data$LotFrontage),]$LotFrontage <- 0
#Ersetze Alley NA durch "NoAlley"
data[is.na(data$Alley),]$Alley <- "NoAlley"
#Ersetze MiscFeature NA durch "NoMisc"
data[is.na(data$MiscFeature),]$MiscFeature <- "NoMisc"
#Fence
data[is.na(data$Fence),]$Fence <- "NoFence"
#Pool
data[is.na(data$PoolQC),]$PoolQC <- "NoPool"
data = read.csv("01_Data/train.csv", stringsAsFactors = FALSE)
data$Id <- NULL
#Unterteile Daten in Numerische und Kategorielle Variablen
data_chr <- data[,sapply(data, is.character)]
data_int <- data[,sapply(data, is.integer)]
colSums(is.na(data_chr))
colSums(is.na(data_int))
#Ersetze LotFrontage NA durch 0
data[is.na(data$LotFrontage),]$LotFrontage <- 0
#Ersetze Alley NA durch "NoAlley"
data[is.na(data$Alley),]$Alley <- "NoAlley"
#Ersetze MiscFeature NA durch "NoMisc"
data[is.na(data$MiscFeature),]$MiscFeature <- "NoMisc"
#Fence
data[is.na(data$Fence),]$Fence <- "NoFence"
#Pool
data[is.na(data$PoolQC),]$PoolQC <- "NoPool"
colSums(is.na(data_chr))
data[is.na(data$GarageType),]$GarageType <- "NoGarage"
data[is.na(data$GarageType),]$GarageType <- "NoGarage"
data[is.na(data$GarageFinish),]$GarageFinish <- "NoGarage"
data[is.na(data$GarageQual),]$GarageQual <- "NoGarage"
data[is.na(data$GarageCond),]$GarageCond <- "NoGarage"
?mean
